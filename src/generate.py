import json
import os

import torch

from src.dit import DiT
from src.sd_unet import Unet
from src.cardiff import Cardiff


def _read_params(directory, filename):
    """Returns dictionary from JSON config file in the parameters folder of a training directory"""
    with open(os.path.join(directory, "parameters", filename), 'r') as _file:
        return json.loads(_file.read())


def load_params(directory):
    """
    Loads parameters from a training directory
    :param directory: Path of training directory generated by training
    :return: (unets_params, cardiff_params)
    """
    # Files in parameters directory
    files = os.listdir(os.path.join(directory, "parameters"))
    # Filter only param files for U-Nets
    unets_params_files = sorted(list(filter(lambda x: x.startswith("denoiser_", ), files)),
                                key=lambda x: int(x.split("_")[1]))

    # Load U-Nets / MinImagen parameters
    unets_params = [_read_params(directory, f) for f in unets_params_files]
    cardiff_params_files = _read_params(directory, list(filter(lambda x: x.startswith("cardiff_"), files))[0])
    return unets_params, cardiff_params_files


def _instatiate_minimagen(directory):
    # TODO: When restarted training, parameters folder only has the cmd line args, not the unet/imagen params.
    #   had to copy from training folder this one was restarted from. Fix this so it copies.
    """ Instantiate an Imagen model with given parameters """
    denoisers_params, cardiff_params_files = load_params(directory)

    return Cardiff(denoisers=[DiT(**denoisers_params[0]), Unet(**denoisers_params[1])], **cardiff_params_files)


def load_minimagen(directory):
    """
    :param directory: MinImagen training directory as structured according to :func:`.minimagen.training.create_directory`.
    :return: :obj:`MinImagen <.minimagen.Imagen.Imagen>` instance (ready for inference).
    """
    # map_location = torch.device("cuda:9" if torch.cuda.is_available() else "cpu")
    map_location = torch.device("cpu")

    minimagen = _instatiate_minimagen(directory)

    # Filepaths for all statedicts
    files = os.listdir(os.path.join(directory, "state_dicts"))

    # Use tmp folder if state_dicts empty
    if files != []:
        subdir = "state_dicts"
        num_unets = int(max(set([i.split("_")[1] for i in list(filter(lambda x: x.startswith("unet_"), files))]))) + 1

        # Load best state for each unet in the minimagen instance
        unet_state_dicts = [list(filter(lambda x: x.startswith(f"unet_{i}"), files))[0] for i in range(num_unets)]
        for idx, file in enumerate(unet_state_dicts):
            pth = os.path.join(directory, f'{subdir}', file)
            minimagen.unets[idx].load_state_dict(torch.load(pth, map_location=map_location))

    else:
        subdir = "tmp"
        print(f"\n\"state_dicts\" folder in {directory} is empty, using the most recent checkpoint from \"tmp\".\n")
        files = os.listdir(os.path.join(directory, f"{subdir}"))

        if files == []:
            raise ValueError(f"Both \"/state_dicts\" and \"/tmp\" in {directory} are empty. Train the model to acquire state dictionaries for inference. ")

        num_unets = int(max(set([i.split("_")[1] for i in list(filter(lambda x: x.startswith("unet_"), files))]))) + 1


        # Load best state for each unet in the minimagen instance
        unet_state_dicts = [list(filter(lambda x: x.startswith(f"unet_{i}"), files))[0] for i in range(num_unets)]
        for idx, file in enumerate(unet_state_dicts):
            pth = os.path.join(directory, f'{subdir}', file)
            minimagen.unets[idx].load_state_dict(torch.load(pth, map_location=map_location))

    return minimagen


